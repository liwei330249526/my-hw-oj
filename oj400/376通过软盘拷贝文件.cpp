/*
 *
题目描述
有一名科学家想要从一台股东电脑中拷贝文件到自己的电脑中加以研究
但次电脑除了一个3.5寸软盘驱动器意外，没有任何手段可以将文件拷贝出来，而且只有一张软盘可以使用
因此这一张软盘是唯一可以用来拷贝文件的载体
科学家想要尽可能多地讲计算机中的信息拷贝到软盘中，做到软盘中文件内容总大小最大
已知该软盘的容量为147456字节。文件占用的软盘空间都是按块分配的，每个块大小为512字节。一个快只能被一个文件使用。
拷贝到软盘的文件必须是完整的，且不能采取任何压缩技术。

输入
第1行为一个整数N，表示计算机中的文件数量
接下来的第2行到第N+1行，每行为一个整数，表示每个文件的大小Si，单位为字节。
输出
科学家最多能拷贝的文件总大小

样例1
输入
3
737270
737272
737288



输出
1474542




说明：
3个文件中，每个文件实际占用的大小分别为737280字节、737280字节、737792字节

只能选取前两个文件，总大小为 1474542 字节。虽然后两个文件总大小更大且未超过1474560字节，但因为实际占用的大小超过了1474560字节，所以不能选后两个文件。




样例2
输入
6
400000
200000
200000
200000
400000
400000



输出
1400000




说明:
从6个文件中，选择3个大小为400000的文件和1个大小为200000的文件，得到最大总大小为1400000

也可以选择2个大小为400000的文件和3个大小为200000的文件，得到的总大小也是1400000





 *
 * */

#include "iostream"
#include "vector"
using namespace std;
/*
 * dfs xx
 * 01背包
 *
 * */


int main() {
  int n;
  cin >> n;
  vector<int> arr(n);
  for (int i = 0; i < n; i++) {
    cin >> arr[i];
  }

  int tolSize = 2880; // 软盘的空间块数
  vector<int> dp(2880+1,0);
  // dp[j], 背包大小为 j，最多容纳文件大小
  for (int i = 0; i < n; i++) { // 遍历每个物品
    int curSize = (arr[i]+511)/512; // 文件所占块数
    for(int j = dp.size()-1; j >= 0; j--) { // 遍历背包
      if (j >= curSize) { // 背包大于或等于物品大小，可选，可不选
        dp[j] = max(dp[j], dp[j - curSize] + arr[i]);
      } else {
        dp[j] = dp[j]; // 不选
      }
    }
  }

  cout << dp.back() << endl;

  return 0;
}

