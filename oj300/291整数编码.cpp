/*
 *
题目描述
实现一种整数编码方法，使得待编码的数字越小，编码后所占用的字节数越小
编码规则如下：
1 编码时7位一组，每个字节的低7位用于存储待编码数字的补码
2 字节的最高位表示后续是否还有字节，置1表示后面还有更多的字节，置0表示当前字节为最后一个字节
3 采用小端序编码，低位和低字节放在低地址
4 编码结果按 16 进制数的字节格式输出

输入
输入的为一个字符串表示的非负整数
输出
输出一个字符串，表示整数编码的16进制码流

样例1
输入
0

输出
00

说明：
输出的16进制字符，不足两位的前面补0,如00、01、02


样例2
输入
100


输出
64


说明：
100的二进制表示为0110 0100,只需要一个字节进行编码,
字节的最高位置0，剩余7位存储数字100的低7位(110 0100)，所以编码后的输出为64


样例3
输入
1000



输出
E807


1000的二进制表示为0011 1110 1000，至少需要两个字节进行编码;

第一个字节最高位置1,剩余的7位存储数字1000的第一个低7位 (1101000)，所以第一个字节的二 进制为1110 1000,即E8;

第二个字节最高位置0，剩余的7位存储数字1000的第二个低7位(000111),所以第一个字节的二 进制为0000 0111,即07;

采用小端序编码，所以低字节E8输出在前，字节07输出在后



 *
 * */

#include "iostream"
#include "string"
#include "vector"

using namespace std;
int main() {
  // 获取数字
  int num;
  cin >> num;

  if (num == 0) {
    cout << "00" << endl;
    return 0;
  }

  // 获取所有单字节
  vector<unsigned char> bcs;
  while (num > 0) {
    unsigned char b = num & 0b01111111; // 获取低 7 位    & 1 获取1
    num = num >> 7; // num 右移7位

    if (num != 0) { // | 1， 设置1
      b = b | 0b10000000; // 如果后续还有字节，该字节最高位设置为1
    }

    bcs.push_back(b);
  }


  // 转换成 16 进制
  string res;
  string plt = "0123456789ABCDEF";
  for (int i = 0; i < bcs.size(); i++) {
   int id1 = (bcs[i] >> 4) & 0xf;  // 高4位
   res += plt[id1];

   int id2 = bcs[i] & 0xf; // 第4位
   res += plt[id2];
  }

  cout << res << endl;


  return 0;
}